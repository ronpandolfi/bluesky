.. currentmodule:: bluesky.plans

Plans
=====

In bluesky, a *plan* expresses experimental logic as an iterable (e.g., a list)
of granular instructions.

For example, this is a plan:

.. code-block:: python

    plan = [Msg('set', motor1, 5), Msg('read', detector1)]

Bluesky provides facilities for conveniently generating these plans for many
common use cases, such as:

* one-dimensional trajectories (e.g., linear-, log-, or unevenly-spaced)
* trajectories that move multiple motors together
* N-dimensional trajectories, such as a mesh
* adaptive sampling, adjusting step size in response to readings

These plans are generated Mad-Libs style: "fill in the blacks" with motor(s)
and detector(s), and bluesky generates the set of intructions -- the plan.

That plan can be inspected, modified, customized. Finally, it is passed to
the RunEngine, which supervises its executation and captures any data it
generates.

Usage Example
-------------

.. ipython:: python

    from bluesky.tests.utils import setup_test_run_engine
    RE = setup_test_run_engine()
    from bluesky.examples import motor, det1, det2, det3

Make an instance of a plan, passing in parameters.

.. ipython:: python

    print(RE.dispatcher.cb_registry.callbacks)
    print(RE._lossless_dispatcher.cb_registry.callbacks)
    from bluesky.plans import AbsScanPlan
    plan = AbsScanPlan([det1, det2], motor, 1, 5, 10)
    print(plan.subs)

Running the plan is a separate step. The same plan can be run multiple times
without respecifying its parameters.

.. ipython:: python

    print(RE.dispatcher.cb_registry.callbacks)
    print(RE._lossless_dispatcher.cb_registry.callbacks)
    print(plan.subs)
    RE(plan)
    RE(plan)

Any of the plan's parameters can be updated individually.

.. ipython:: python

    print(RE.dispatcher.cb_registry.callbacks)
    print(RE._lossless_dispatcher.cb_registry.callbacks)
    plan.num = 4  # change number of data points from 10 to 4
    RE(plan)
    plan.detectors.append(det3)  # add another detector
    RE(plan)

The ``set`` method is a convenient way to update multiple parameters at once.

.. ipython:: python

    plan.set(start=20, stop=25)

Concatenating Plans
-------------------

Plans are iterables (roughly speaking, lists) and the Python language has nice
facilities found handling them. For example to join to plans together, use
``chain``.

.. ipython:: python

    from itertools import chain

    plan1 = AbsScanPlan([det1, det2], motor, 1, 5, 3)  # 1 to 5 in 3 steps
    plan2 = AbsScanPlan([det1], motor, 5, 10, 2)  # 5 to 10 in 2 steps

    # Do this.
    master_plan = chain(plan1, plan2)
    print(RE.dispatcher.cb_registry.callbacks)
    print(RE._lossless_dispatcher.cb_registry.callbacks)
    RE(master_plan)
    print(RE.dispatcher._token_mapping)

Notice that the RunEngine retured a list of two unique IDs, one for each
dataset generated by the plans. This has advantages over executing them in
sequence like so:

.. ipython:: python

    # Don't do this.
    RE(plan1); RE(plan2)

If there are no interruptions or errors, these two methods are equivalent. But
in the event of a problem, the RunEngine can do more to recover if it
maintains control. In the second example, it loses control between completing
``plan1`` and beginning ``plan2``.

What if want to ``print`` or do other activities between executing the plans?
There is another way to combine plans to accomodate this.

.. code-block:: python

    plan1 = AbsScanPlan([det1, det2], motor, 1, 5, 10)
    plan2 = DeltaScanPlan([det1], motor, 5, 10, 10)

    def make_master_plan():
        yield from plan1
        print('plan1 is finished -- moving onto plan2')
        yield from plan2

    RE(make_master_plan())  # note the ()

Arbitrary Python code can go inside ``master_plan``. It could employ ``if``
blocks, ``for`` loops -- anything except a ``return`` statement. If you want to
know more about what is happening here, structures like this in Python are
called *generators*.

Here are a couple more useful recipes:

.. code-block:: python

    "Run plan1, wait for user confirmation, then run plan2."

    def make_master_plan():
        yield from plan1
        # pause and consult the user
        if input('continue? (y/n)') != 'y':
            raise StopIteration
        yield from plan2

.. code-block:: python

    "Run a plan several times, changing the step size each time."

    def make_master_plan():
        for num in range(5, 10):
            plan1.num = num  # update the number of steps in the plan
            yield from plan1

Count
-----

.. autofunction:: Count

1D Plans
--------

.. autofunction:: AbsScanPlan
.. autofunction:: LogAbsScanPlan
.. autofunction:: AbsListScanPlan
.. autofunction:: DeltaScanPlan
.. autofunction:: LogDeltaScanPlan
.. autofunction:: DeltaListScanPlan

N-dimensional Plans
-------------------

.. autofunction:: InnerProductAbsScanPlan
.. autofunction:: OuterProductAbsScanPlan
.. autofunction:: InnerProductDeltaScanPlan
.. autofunction:: OuterProductDeltaScanPlan
.. autofunction:: PlanND

.. _builtin-adaptive-scans:

Adaptive Plans
--------------

.. autofunction:: AdaptiveAbsScanPlan
.. autofunction:: AdaptiveDeltaScanPlan
.. autofunction:: Center

Interactive Plans
-----------------

.. autofunction:: Tweak
